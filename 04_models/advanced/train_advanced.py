#!/usr/bin/env python3
"""
Train advanced EmberSense models with experiment tracking and versioning.

Usage:
    python 04_models/advanced/train_advanced.py \
        --config 04_models/advanced/configs/cnn_fusion_v2.json \
        --experiment-name exp_001 \
        --version v2.0 \
        --edge-impulse-project-id <PROJECT_ID>
"""

from __future__ import annotations

import argparse
import json
import subprocess
import time
from pathlib import Path
from typing import Dict, Any

import pandas as pd


def load_config(config_path: Path) -> Dict[str, Any]:
    """Load model configuration from JSON."""
    return json.loads(config_path.read_text(encoding="utf-8"))


def create_experiment_dir(experiment_name: str, base_dir: Path) -> Path:
    """Create experiment directory and return path."""
    exp_dir = base_dir / "experiments" / experiment_name
    exp_dir.mkdir(parents=True, exist_ok=True)
    return exp_dir


def log_experiment_start(config: Dict, experiment_dir: Path) -> Dict:
    """Log experiment metadata at start."""
    metadata = {
        "experiment_id": experiment_dir.name,
        "started_at": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        "config": config,
        "status": "running",
    }
    log_path = experiment_dir / "experiment_metadata.json"
    log_path.write_text(json.dumps(metadata, indent=2), encoding="utf-8")
    return metadata


def train_via_edge_impulse(config: Dict, project_id: str, experiment_dir: Path) -> Dict:
    """Train model using Edge Impulse CLI."""
    print(f"[training] Starting Edge Impulse training for {config['model_name']}")
    
    # Export config for Edge Impulse BYOM
    ei_config_path = experiment_dir / "edge_impulse_config.json"
    ei_config = {
        "model_type": config["architecture"]["type"],
        "input_shape": "inferred_from_dsp",
        "output_classes": 3,
    }
    ei_config_path.write_text(json.dumps(ei_config, indent=2), encoding="utf-8")
    
    # Log training command (actual execution requires EI API key)
    log_path = experiment_dir / "training_log.txt"
    with log_path.open("a", encoding="utf-8") as f:
        f.write(f"[{time.strftime('%Y-%m-%dT%H:%M:%SZ')}] Training started\n")
        f.write(f"Config: {config['model_name']} v{config['version']}\n")
        f.write(f"Edge Impulse Project ID: {project_id}\n")
        f.write("\nCommand (requires EI API key):\n")
        f.write(f"edge-impulse-cli --api-key $EI_API_KEY --project-id {project_id} \\\n")
        f.write("  ml train --config {ei_config_path} --epochs {config['training']['epochs']}\n")
    
    # Placeholder for actual training
    print("[training] NOTE: Actual training requires Edge Impulse API key")
    print(f"[training] Config saved to {ei_config_path}")
    
    return {
        "training_method": "edge_impulse",
        "config_path": str(ei_config_path),
        "status": "pending_api_key",
    }


def train_via_pytorch(config: Dict, experiment_dir: Path) -> Dict:
    """Train model using PyTorch (BYOM)."""
    print(f"[training] PyTorch training for {config['model_name']}")
    
    # Create PyTorch training script
    script_path = experiment_dir / "train_pytorch.py"
    script_content = f'''#!/usr/bin/env python3
"""
PyTorch training script for {config['model_name']} v{config['version']}
Generated by train_advanced.py
"""

import torch
import torch.nn as nn
from torch.utils.data import DataLoader

# Model architecture would be defined here based on config
# This is a placeholder structure

class {config['model_name'].replace('-', '_').title()}Model(nn.Module):
    def __init__(self, config):
        super().__init__()
        # Architecture implementation based on config
        pass
    
    def forward(self, x):
        # Forward pass
        pass

# Training loop would go here
'''
    script_path.write_text(script_content, encoding="utf-8")
    
    log_path = experiment_dir / "training_log.txt"
    with log_path.open("a", encoding="utf-8") as f:
        f.write(f"[{time.strftime('%Y-%m-%dT%H:%M:%SZ')}] PyTorch training script created\n")
        f.write(f"Script: {script_path}\n")
    
    return {
        "training_method": "pytorch",
        "script_path": str(script_path),
        "status": "script_generated",
    }


def save_model_version(config: Dict, experiment_dir: Path, version: str, results: Dict) -> Path:
    """Save model version with metadata."""
    version_dir = Path("04_models/advanced/versions") / version
    version_dir.mkdir(parents=True, exist_ok=True)
    
    version_metadata = {
        "version": version,
        "model_name": config["model_name"],
        "created_at": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        "experiment_id": experiment_dir.name,
        "config": config,
        "results": results,
    }
    
    metadata_path = version_dir / "version_metadata.json"
    metadata_path.write_text(json.dumps(version_metadata, indent=2), encoding="utf-8")
    
    # Copy experiment artifacts
    import shutil
    if (experiment_dir / "model.h5").exists():
        shutil.copy(experiment_dir / "model.h5", version_dir / "model.h5")
    if (experiment_dir / "model.eim").exists():
        shutil.copy(experiment_dir / "model.eim", version_dir / "model.eim")
    
    print(f"[versioning] Model version {version} saved to {version_dir}")
    return version_dir


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Train advanced EmberSense models.")
    parser.add_argument(
        "--config",
        type=Path,
        required=True,
        help="Path to model configuration JSON",
    )
    parser.add_argument(
        "--experiment-name",
        type=str,
        required=True,
        help="Unique experiment identifier",
    )
    parser.add_argument(
        "--version",
        type=str,
        required=True,
        help="Model version tag (e.g., v2.0)",
    )
    parser.add_argument(
        "--method",
        type=str,
        choices=["edge_impulse", "pytorch", "tensorflow"],
        default="edge_impulse",
        help="Training method",
    )
    parser.add_argument(
        "--edge-impulse-project-id",
        type=str,
        help="Edge Impulse project ID (required for EI method)",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    config = load_config(args.config)
    
    base_dir = Path("04_models/advanced")
    experiment_dir = create_experiment_dir(args.experiment_name, base_dir)
    
    metadata = log_experiment_start(config, experiment_dir)
    print(f"[experiment] Started {args.experiment_name} in {experiment_dir}")
    
    # Train based on method
    if args.method == "edge_impulse":
        if not args.edge_impulse_project_id:
            raise ValueError("--edge-impulse-project-id required for Edge Impulse training")
        results = train_via_edge_impulse(config, args.edge_impulse_project_id, experiment_dir)
    elif args.method == "pytorch":
        results = train_via_pytorch(config, experiment_dir)
    else:
        raise NotImplementedError(f"Training method {args.method} not yet implemented")
    
    # Update experiment metadata
    metadata["results"] = results
    metadata["completed_at"] = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    metadata["status"] = "completed"
    
    log_path = experiment_dir / "experiment_metadata.json"
    log_path.write_text(json.dumps(metadata, indent=2), encoding="utf-8")
    
    # Save model version
    version_dir = save_model_version(config, experiment_dir, args.version, results)
    
    print(f"[experiment] Completed {args.experiment_name}")
    print(f"[version] Model versioned as {args.version} in {version_dir}")


if __name__ == "__main__":
    main()

