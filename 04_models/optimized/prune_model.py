#!/usr/bin/env python3
"""
Prune EmberSense models to reduce size and latency.

Usage:
    python 04_models/optimized/prune_model.py \
        --input-model 04_models/advanced/versions/v2.0/model.h5 \
        --output-dir 04_models/optimized/pruned/v2.0_pruned \
        --sparsity 0.5 \
        --method magnitude
"""

from __future__ import annotations

import argparse
import json
import time
from pathlib import Path
from typing import Dict, Any


def load_pruning_config(config_path: Path) -> Dict[str, Any]:
    """Load pruning configuration."""
    return json.loads(config_path.read_text(encoding="utf-8"))


def create_pruning_script(
    input_model: Path,
    output_dir: Path,
    method: str,
    sparsity: float,
    config: Dict[str, Any]
) -> Path:
    """Create pruning script for TensorFlow Model Optimization Toolkit."""
    output_dir.mkdir(parents=True, exist_ok=True)
    
    script_path = output_dir / "prune_model.py"
    
    pruning_config = config.get("pruning_methods", {}).get(method, {})
    
    script_content = f'''#!/usr/bin/env python3
"""
Model pruning script using TensorFlow Model Optimization Toolkit.
Generated by prune_model.py
"""

import tensorflow as tf
import tensorflow_model_optimization as tfmot
import numpy as np

# Load model
print("Loading model...")
model = tf.keras.models.load_model("{input_model}")

# Pruning parameters
pruning_params = {{
    'pruning_schedule': tfmot.sparsity.keras.PolynomialDecay(
        initial_sparsity={pruning_config.get('initial_sparsity', 0.0)},
        final_sparsity={sparsity},
        begin_step={pruning_config.get('begin_step', 0)},
        end_step={pruning_config.get('end_step', 1000)},
        frequency={pruning_config.get('frequency', 100)}
    )
}}

# Apply pruning
print("Applying pruning...")
prune_low_magnitude = tfmot.sparsity.keras.prune_low_magnitude
model_for_pruning = prune_low_magnitude(model, **pruning_params)

# Compile model
model_for_pruning.compile(
    optimizer='adam',
    loss='categorical_crossentropy',
    metrics=['accuracy']
)

# Fine-tune (placeholder - implement with actual training data)
print("Fine-tuning pruned model...")
# model_for_pruning.fit(x_train, y_train, epochs=10, validation_data=(x_val, y_val))

# Strip pruning wrappers
print("Stripping pruning wrappers...")
model_for_export = tfmot.sparsity.keras.strip_pruning(model_for_pruning)

# Save pruned model
output_path = "{output_dir / 'model_pruned.h5'}"
model_for_export.save(output_path)

# Calculate model size
import os
model_size_kb = os.path.getsize(output_path) / 1024
print(f"Pruned model saved to {{output_path}}")
print(f"Model size: {{model_size_kb:.2f}} KB")

# Save pruning statistics
stats = {{
    "original_size_kb": os.path.getsize("{input_model}") / 1024,
    "pruned_size_kb": model_size_kb,
    "reduction_pct": (1 - model_size_kb / (os.path.getsize("{input_model}") / 1024)) * 100,
    "sparsity": {sparsity}
}}

import json
stats_path = "{output_dir / 'pruning_stats.json'}"
with open(stats_path, 'w') as f:
    json.dump(stats, f, indent=2)

print(f"Pruning statistics saved to {{stats_path}}")
'''
    
    script_path.write_text(script_content, encoding="utf-8")
    return script_path


def prune_model(
    input_model: Path,
    output_dir: Path,
    method: str,
    sparsity: float,
    config: Dict[str, Any]
) -> Dict[str, Any]:
    """Prune model and save metadata."""
    output_dir.mkdir(parents=True, exist_ok=True)
    
    print(f"[pruning] Starting {method} pruning with {sparsity:.0%} sparsity")
    
    # Create pruning script
    script_path = create_pruning_script(input_model, output_dir, method, sparsity, config)
    
    # Create metadata
    metadata = {
        "pruning_method": method,
        "sparsity": sparsity,
        "input_model": str(input_model),
        "output_path": str(output_dir / "model_pruned.h5"),
        "script_path": str(script_path),
        "pruned_at": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        "status": "script_generated",
    }
    
    metadata_path = output_dir / "pruning_metadata.json"
    metadata_path.write_text(json.dumps(metadata, indent=2), encoding="utf-8")
    
    log_path = output_dir / "pruning_log.txt"
    with log_path.open("w", encoding="utf-8") as f:
        f.write(f"Pruning started: {time.strftime('%Y-%m-%dT%H:%M:%SZ')}\n")
        f.write(f"Input model: {input_model}\n")
        f.write(f"Method: {method}\n")
        f.write(f"Sparsity: {sparsity:.0%}\n")
        f.write(f"Script: {script_path}\n")
        f.write("\nTo execute pruning, run:\n")
        f.write(f"python {script_path}\n")
    
    print(f"[pruning] Pruning script generated: {script_path}")
    print(f"[pruning] Metadata saved to {metadata_path}")
    
    return metadata


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Prune models for MCU deployment.")
    parser.add_argument(
        "--input-model",
        type=Path,
        required=True,
        help="Path to input model (H5)",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        required=True,
        help="Output directory for pruned model",
    )
    parser.add_argument(
        "--sparsity",
        type=float,
        default=0.5,
        help="Target sparsity (0.0-1.0)",
    )
    parser.add_argument(
        "--method",
        type=str,
        choices=["magnitude", "structured", "iterative"],
        default="magnitude",
        help="Pruning method",
    )
    parser.add_argument(
        "--config",
        type=Path,
        default=Path("04_models/optimized/configs/pruning_config.json"),
        help="Pruning configuration file",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    config = load_pruning_config(args.config)
    
    if not 0.0 <= args.sparsity <= 1.0:
        raise ValueError("Sparsity must be between 0.0 and 1.0")
    
    metadata = prune_model(
        args.input_model,
        args.output_dir,
        args.method,
        args.sparsity,
        config
    )
    
    print(f"[pruning] Pruning setup complete")
    print(f"[pruning] Output directory: {args.output_dir}")


if __name__ == "__main__":
    main()

